<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SpaceTrain: Orbital Logistics Mk.X</title>
    <style>
        :root { --primary: #00d2ff; --action: #00ffaa; --warn: #ffcc00; --danger: #ff3333; --bg: #000000; --panel: rgba(10, 16, 26, 0.90); }
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', monospace; background-color: var(--bg); color: #fff; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Panels */
        .panel {
            position: absolute; width: 320px; padding: 20px; border-radius: 12px;
            background: var(--panel); border: 1px solid #223344;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); z-index: 100;
        }
        #controls-panel { top: 20px; left: 20px; }
        #stats-panel { top: 20px; right: 20px; text-align: right; }

        h2 { margin: 0 0 15px 0; font-size: 14px; text-transform: uppercase; letter-spacing: 3px; color: var(--primary); border-bottom: 1px solid #333; padding-bottom: 8px;}
        h3 { margin: 10px 0 5px 0; font-size: 11px; color: #8899aa; text-transform: uppercase; }

        .control-group { margin-bottom: 15px; }
        label { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 5px; color: #aaa; text-transform: uppercase; }
        input[type=range] { width: 100%; accent-color: var(--primary); background: #222; height: 4px; border-radius: 2px; cursor: pointer; }
        
        button {
            width: 100%; padding: 12px; background: linear-gradient(90deg, #004455, #002233); color: var(--primary); border: 1px solid #005566;
            font-weight: bold; cursor: pointer; text-transform: uppercase; margin-top: 10px; font-size: 11px; transition: 0.2s; letter-spacing: 1px;
        }
        button:hover { background: var(--primary); color: #000; box-shadow: 0 0 20px var(--primary); }

        .stat-big { font-size: 32px; font-weight: bold; color: #fff; line-height: 1; margin-bottom: 2px; text-shadow: 0 0 10px var(--action);}
        .stat-label { font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 1px;}

        /* Loading Screen */
        #loader {
            position: fixed; top:0; left:0; width:100%; height:100%; background: #000; z-index: 999;
            display: flex; justify-content: center; align-items: center; font-size: 20px; color: var(--primary);
            transition: opacity 1s ease-out; pointer-events: none;
        }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

<div id="loader">INITIALIZING DIGITAL TWIN...</div>

<div id="controls-panel" class="panel">
    <h2>Global Operations</h2>
    
    <div class="control-group">
        <label>Simulation Speed</label>
        <input type="range" id="in-speed" min="0.1" max="4.0" value="1.0" step="0.1">
    </div>

    <div class="control-group">
        <label>Global Launch Cadence</label>
        <input type="range" id="in-freq" min="0" max="15" value="4" step="1">
    </div>

    <div class="control-group">
        <label>Interceptor Fleet: <span id="val-drones">8</span></label>
        <input type="range" id="in-drones" min="0" max="30" value="8" step="1">
    </div>

    <button id="btn-reset">System Reset</button>
</div>

<div id="stats-panel" class="panel">
    <h2>Warehouse Analytics</h2>
    
    <div style="margin-bottom: 20px;">
        <div id="stat-stored" class="stat-big">0</div>
        <div class="stat-label">Metric Tons Secured</div>
    </div>
    
    <div style="margin-bottom: 20px;">
        <div id="stat-orbit" class="stat-big" style="color:var(--primary); text-shadow:none;">0</div>
        <div class="stat-label">Pending Intercept</div>
    </div>

    <div style="margin-top:20px; border-top:1px solid #333; padding-top:15px;">
        <div id="stat-status" style="color:var(--primary); font-size:12px; letter-spacing:2px; font-weight:bold;">OPTIMAL</div>
    </div>
</div>

<div id="canvas-container"></div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- CONFIGURATION ---
    const R_EARTH = 50; 
    const ORBIT_RADIUS = 90; 
    
    // Launch Sites (Lat, Lon)
    const CITIES = [
        { name: "London", lat: 51.50, lon: -0.12 },
        { name: "Shanghai", lat: 31.23, lon: 121.47 },
        { name: "Kennedy Space Ctr", lat: 28.57, lon: -80.64 },
        { name: "Dubai", lat: 25.20, lon: 55.27 },
        { name: "Singapore", lat: 1.35, lon: 103.81 },
        { name: "Vandenberg", lat: 34.63, lon: -120.61 }
    ];

    // --- STATE ---
    let simSpeed = 1.0;
    let projectiles = [];
    let drones = [];
    let spawnTimer = 0;
    let stats = { stored: 0 };

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
    camera.position.set(0, 100, 250); 

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.3;

    // --- LIGHTING ---
    const sun = new THREE.DirectionalLight(0xffffff, 2.5);
    sun.position.set(200, 50, 100);
    scene.add(sun);
    const ambient = new THREE.AmbientLight(0x404040, 0.5); 
    scene.add(ambient);

    // --- ASSETS & PLANET ---
    const earthGroup = new THREE.Group();
    scene.add(earthGroup);

    // 1. Earth Mesh with Texture
    const texLoader = new THREE.TextureLoader();
    const earthGeo = new THREE.SphereGeometry(R_EARTH, 64, 64);
    const earthMat = new THREE.MeshPhongMaterial({ 
        color: 0xffffff,
        specular: 0x333333,
        shininess: 5
    });
    
    // Load Blue Marble texture
    texLoader.load('https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg', (tex) => {
        earthMat.map = tex;
        earthMat.needsUpdate = true;
        document.getElementById('loader').style.opacity = 0; 
    }, undefined, (err) => {
        // Fallback if texture fails (e.g., offline)
        earthMat.color.set(0x112244);
        console.error('Failed to load Earth texture, using solid color fallback.', err);
        document.getElementById('loader').style.opacity = 0; 
    });

    const earth = new THREE.Mesh(earthGeo, earthMat);
    earthGroup.add(earth);

    // 2. Atmosphere Glow (Shader approximation)
    const atmGeo = new THREE.SphereGeometry(R_EARTH + 2, 64, 64);
    const atmMat = new THREE.MeshBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0.15, side: THREE.BackSide, blending: THREE.AdditiveBlending });
    earthGroup.add(new THREE.Mesh(atmGeo, atmMat));

    // 3. Orbital Ring (The "Storage" Zone)
    const orbitRingGeo = new THREE.RingGeometry(ORBIT_RADIUS - 0.5, ORBIT_RADIUS + 0.5, 128);
    const orbitRingMat = new THREE.MeshBasicMaterial({ color: 0x00d2ff, side: THREE.DoubleSide, transparent: true, opacity: 0.2 });
    const orbitRing = new THREE.Mesh(orbitRingGeo, orbitRingMat);
    orbitRing.rotation.x = Math.PI / 2;
    scene.add(orbitRing);

    // 4. Warehouse Hub
    const hubGroup = new THREE.Group();
    hubGroup.position.set(ORBIT_RADIUS, 0, 0);
    scene.add(hubGroup);

    // Hub geometry
    const hubBody = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 12), new THREE.MeshBasicMaterial({ color: 0xaaaaaa }));
    const hubLights = new THREE.Mesh(new THREE.BoxGeometry(7, 2, 10), new THREE.MeshBasicMaterial({ color: 0x00d2ff }));
    hubGroup.add(hubBody);
    hubGroup.add(hubLights);

     // --- MATH HELPERS ---
     function latLonToVector(lat, lon, r) {
         const phi = (90 - lat) * (Math.PI / 180);
         const theta = (lon + 180) * (Math.PI / 180);
         return new THREE.Vector3(
             -(r * Math.sin(phi) * Math.cos(theta)),
             (r * Math.cos(phi)),
             (r * Math.sin(phi) * Math.sin(theta))
         );
     }

     function moveOnOrbitalShell(current, target, maxStep, options = {}) {
         const { radiusLerp = 0.25, minRadius = R_EARTH + 2, maxRadius = ORBIT_RADIUS } = options;

         const currentDir = current.clone().normalize();
         const targetDir = target.clone().normalize();

         // If we're already aligned, snap to blended radius
         const angle = currentDir.angleTo(targetDir);
         const targetRadius = THREE.MathUtils.clamp(
             THREE.MathUtils.lerp(current.length(), target.length(), radiusLerp),
             minRadius,
             maxRadius
         );
         if (angle < 1e-4) {
             return targetDir.multiplyScalar(targetRadius);
         }

         const step = Math.min(maxStep, angle);
         const axis = currentDir.clone().cross(targetDir);

         if (axis.lengthSq() < 1e-8) {
             // Opposing or identical directions: pick a stable axis
             axis.set(0, 1, 0);
         }

         const quat = new THREE.Quaternion().setFromAxisAngle(axis.normalize(), step);
         return currentDir.clone().applyQuaternion(quat).normalize().multiplyScalar(targetRadius);
     }

    // --- CLASSES ---

    class Projectile {
        constructor() {
            this.active = true;
            this.captured = false;
            this.phase = 'LAUNCH'; // LAUNCH, INSERTION, ORBIT
            this.driftAxis = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.1, Math.random() - 0.5).normalize();
            if (this.driftAxis.lengthSq() < 1e-4) { this.driftAxis.set(0, 1, 0); }
            this.driftSpeed = 0.05 + Math.random() * 0.08;

            // 1. Pick Random City
            const city = CITIES[Math.floor(Math.random() * CITIES.length)];
            this.pos = latLonToVector(city.lat, city.lon, R_EARTH);
            
            // Visuals
            this.mesh = new THREE.Mesh(
                new THREE.OctahedronGeometry(1.2, 0),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            this.mesh.position.copy(this.pos);
            scene.add(this.mesh);

            // Calculate Launch Vector 
            this.targetOrbitPos = this.pos.clone().normalize().multiplyScalar(ORBIT_RADIUS);
            
            // Random orbital offset 
            const axis = new THREE.Vector3(0, 1, 0);
            const angle = (Math.random() - 0.5) * 0.5;
            this.targetOrbitPos.applyAxisAngle(axis, angle);
        }

        update(dt) {
            if (!this.active) return;

            if (this.phase === 'LAUNCH') {
                // Lerp to orbit height
                const speed = 25 * dt;
                const dist = this.pos.distanceTo(this.targetOrbitPos);
                
                if (dist < 1) {
                    this.phase = 'ORBIT';
                } else {
                    const dir = new THREE.Vector3().subVectors(this.targetOrbitPos, this.pos).normalize();
                    this.pos.add(dir.multiplyScalar(speed));
                }
            }
            else if (this.phase === 'ORBIT') {
                // Only drift if not targeted/captured by a drone
                if (!this.captured) {
                    // Free-drift around a randomized orbital plane
                    const speed = this.driftSpeed * dt;
                    this.pos.applyAxisAngle(this.driftAxis, speed);
                }
                // If CAPTURED, position is locked to drone (managed by Drone class)
            }
            

            this.mesh.position.copy(this.pos);
            this.mesh.rotation.x += dt * 2;
        }

        remove() {
            this.active = false;
            scene.remove(this.mesh);
        }
    }

     class Drone {
         constructor() {
             this.state = 'IDLE'; // IDLE, TRANSIT_OUT, TRANSIT_IN
             this.target = null;
             this.captureThreshold = 8; // Relaxed capture distance (was 5)
             this.lowArc = R_EARTH + 10; // Atmosphere-skimming transfer shell
             this.approachComplete = false;

             // Start at Hub
             this.pos = hubGroup.position.clone();

             // Visuals
             this.mesh = new THREE.Mesh(
                 new THREE.ConeGeometry(1.5, 4, 8),
                 new THREE.MeshBasicMaterial({ color: 0x00d2ff })
             );
             this.mesh.geometry.rotateX(Math.PI / 2);
             scene.add(this.mesh);

             // Tether
             const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
             this.tether = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0x00ffaa, transparent: true, opacity: 0 }));
             scene.add(this.tether);
         }

         update(dt) {
             const SPEED = 0.8 * dt;
             const HUB_POS = hubGroup.position;

             if (this.state === 'IDLE') {
                 // Park at Hub
                 this.pos.copy(HUB_POS);
                 this.approachComplete = false;

                 // Find Target
                 const p = projectiles.find(p => p.active && p.phase === 'ORBIT' && !p.captured);
                 if (p) {
                     this.target = p;
                     this.target.captured = true; // Lock target orbit drift now!
                     this.state = 'TRANSIT_OUT';
                     this.approachComplete = false;
                 }
             }
             else if (this.state === 'TRANSIT_OUT') {
                 if (!this.target.active) { this.state = 'IDLE'; return; }

                 // Stage 1: Dive to a lower transfer shell for global routing
                 const approachVector = this.target.pos.clone().setLength(this.lowArc);
                 if (!this.approachComplete) {
                     this.pos.copy(moveOnOrbitalShell(this.pos, approachVector, SPEED, { radiusLerp: 0.4, minRadius: this.lowArc, maxRadius: ORBIT_RADIUS }));
                     if (this.pos.distanceTo(approachVector) < 2) {
                         this.approachComplete = true;
                     }
                 } else {
                     // Stage 2: Rise back up toward the target's current shell
                     this.pos.copy(moveOnOrbitalShell(this.pos, this.target.pos, SPEED, { radiusLerp: 0.35, minRadius: this.lowArc }));
                 }

                 this.mesh.lookAt(this.target.pos);

                 // Check distance - Use relaxed threshold
                 if (this.pos.distanceTo(this.target.pos) < this.captureThreshold) {
                     this.state = 'TRANSIT_IN';
                     this.mesh.material.color.setHex(0x00ffaa); // Green for haul
                     this.tether.material.opacity = 1;
                 }
             }
             else if (this.state === 'TRANSIT_IN') {
                 // Haul payload back to Hub following a great-circle arc
                 this.pos.copy(moveOnOrbitalShell(this.pos, HUB_POS, SPEED * 0.7, { radiusLerp: 0.35 }));

                 // Sync Payload: Position it slightly behind the drone on the orbital path
                 const droneDir = this.pos.clone().normalize();
                 this.target.pos.copy(this.pos).sub(droneDir.multiplyScalar(4));

                 // Update Tether
                 const tetherPoints = [this.pos, this.target.pos];
                 this.tether.geometry.setFromPoints(tetherPoints);
                 this.tether.geometry.attributes.position.needsUpdate = true;

                 this.mesh.lookAt(HUB_POS);

                 // Check arrival: Distance to the hub's fixed location
                 if (this.pos.distanceTo(HUB_POS) < 5) {
                     // Deposit
                     stats.stored++;
                     this.target.remove();
                     this.target = null;
                     this.state = 'IDLE';
                     this.mesh.material.color.setHex(0x00d2ff);
                     this.tether.material.opacity = 0;
                 }
             }

             this.mesh.position.copy(this.pos);
         }
     }

    // --- MAIN LOOP ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const rawDt = clock.getDelta();
        const dt = rawDt * simSpeed;

        controls.update();

        // Rotate Earth slowly
        earthGroup.rotation.y += 0.05 * dt;

        // Rotate Orbital Ring slowly (opposing direction)
        orbitRing.rotation.z -= 0.02 * dt;

        // Spawn Logic
        const freq = parseInt(document.getElementById('in-freq').value);
        if (freq > 0) {
            spawnTimer += dt;
            if (spawnTimer > (5 / freq)) {
                projectiles.push(new Projectile());
                spawnTimer = 0;
            }
        }

        // Projectile Updates
        projectiles.forEach(p => p.update(dt));
        projectiles = projectiles.filter(p => p.active);

        // Drone Updates
        const desiredDrones = parseInt(document.getElementById('in-drones').value);
        while(drones.length < desiredDrones) drones.push(new Drone());
        while(drones.length > desiredDrones) {
            const d = drones.pop();
            scene.remove(d.mesh); scene.remove(d.tether);
            if(d.target) { d.target.captured = false; }
        }
        drones.forEach(d => d.update(dt));

        // UI Updates
        document.getElementById('stat-orbit').innerText = projectiles.filter(p => p.phase === 'ORBIT' && !p.captured).length;
        document.getElementById('stat-stored').innerText = stats.stored;
        
        const statusEl = document.getElementById('stat-status');
        const pending = projectiles.filter(p => p.phase === 'ORBIT' && !p.captured).length;
        const activeDrones = drones.filter(d => d.state !== 'IDLE').length;
        
        if (pending > 0 && activeDrones === drones.length) {
            statusEl.innerText = "FLEET SATURATED";
            statusEl.style.color = "#ffcc00";
        } else if (pending > 0 && activeDrones < drones.length) {
            statusEl.innerText = "DEPLOYING";
            statusEl.style.color = "#00d2ff";
        } else {
            statusEl.innerText = "OPTIMAL";
            statusEl.style.color = "#00ffaa";
        }

        renderer.render(scene, camera);
    }

    // Inputs
    document.getElementById('in-speed').addEventListener('input', e => simSpeed = parseFloat(e.target.value));
    document.getElementById('in-drones').addEventListener('input', e => document.getElementById('val-drones').innerText = e.target.value);
    document.getElementById('btn-reset').addEventListener('click', () => {
        projectiles.forEach(p => p.remove());
        projectiles = [];
        stats.stored = 0;
        // Resetting drones to IDLE state
        drones.forEach(d => {
             if(d.target) { d.target.captured = false; }
             d.target = null;
             d.state = 'IDLE';
             d.mesh.material.color.setHex(0x00d2ff);
             d.tether.material.opacity = 0;
        });
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>
